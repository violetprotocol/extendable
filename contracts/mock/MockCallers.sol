//SPDX-License-Identifier: LGPL-3.0
pragma solidity ^0.8.4;

import "hardhat/console.sol";
import "../extensions/permissioning/PermissioningLogic.sol";

library Revert {
    function require(bool expected) internal pure {
        assembly {
            switch expected
            case 0 { 
                let ptr := mload(0x40)
                returndatacopy(ptr, 0, returndatasize())
                revert(ptr, returndatasize()) 
            }
        }
    }
}

// generated by extended contract
interface IExtended {
    // from ExtendLogic interface
    function extend(address extension) external;
    function getCurrentInterface() external returns(string memory);
    function getExtensions() external returns(address[] memory);

    // from PermissioningLogic interface
    function init() external;
    function updateOwner(address newOwner) external;
    function getOwner() external returns(address);

    // from IssueLogic interface
    function issue() external;
    function issueTo(address recipient) external;

    // from RevokeLogic interface
    function revoke(address recipient) external;

    function expire() external; // fake function that is not implemented by the target contract and should fail when called with "not implemented"
}

contract ExtendCaller {
    address internal _extendLogic;

    constructor(address permissioninglogic, address extendLogic) {
        (bool success, ) = permissioninglogic.delegatecall(abi.encodeWithSignature("init()"));
        Revert.require(success);
        _extendLogic = extendLogic;
    }

    function getOwner(address permissioninglogic) public returns(address owner) {
        (bool success, bytes memory result) = permissioninglogic.delegatecall(abi.encodeWithSignature("getOwner()"));
        Revert.require(success);
        owner = abi.decode(result, (address));
        return(owner);
    }

    function callExtend(address extension) public {
        (bool success, ) = _extendLogic.delegatecall(abi.encodeWithSignature("extend(address)", extension));
        Revert.require(success);
    }

    function getCurrentInterface() public returns(string memory) {
        (bool success, bytes memory result) = _extendLogic.delegatecall(abi.encodeWithSignature("getCurrentInterface()"));
        Revert.require(success);
        string memory interfaceString = abi.decode(result, (string));
        return(interfaceString);
    }

    function getExtensions() public returns(bytes4[] memory) {
        (bool success, bytes memory result) = _extendLogic.delegatecall(abi.encodeWithSignature("getExtensions()"));
        Revert.require(success);
        bytes4[] memory extensions = abi.decode(result, (bytes4[]));
        return(extensions);
    }

    function getExtensionAddresses() public returns(address[] memory) {
        (bool success, bytes memory result) = _extendLogic.delegatecall(abi.encodeWithSignature("getExtensionAddresses()"));
        Revert.require(success);
        address[] memory extensions = abi.decode(result, (address[]));
        return(extensions);
    }
}

contract RetractCaller is ExtendCaller {
    address internal _retractLogic;

    constructor(address permissioninglogic, address extendLogic, address retractLogic) ExtendCaller(permissioninglogic, extendLogic) {
        _retractLogic = retractLogic;
    }

    function callRetract(address extension) public {
        (bool success, ) = _retractLogic.delegatecall(abi.encodeWithSignature("retract(address)", extension));
        Revert.require(success);
    }
}

contract ReplaceCaller is RetractCaller {
    address internal _replaceLogic;

    constructor(address permissioninglogic, address extendLogic, address retractLogic, address replaceLogic) RetractCaller(permissioninglogic, extendLogic, retractLogic) {
        _replaceLogic = replaceLogic;
    }

    function callReplace(address oldExtension, address newExtension) public {
        (bool success, ) = _replaceLogic.delegatecall(abi.encodeWithSignature("replace(address,address)", oldExtension, newExtension));
        Revert.require(success);
        if (oldExtension == _replaceLogic) _setReplaceLogicAddress(newExtension);
        if (oldExtension == _retractLogic) _setRetractLogicAddress(newExtension);
        if (oldExtension == _extendLogic) _setExtendLogicAddress(newExtension);
    }

    function _setReplaceLogicAddress(address replaceLogic) internal {
        _replaceLogic = replaceLogic;
    }

    function _setRetractLogicAddress(address retractLogic) internal {
        _retractLogic = retractLogic;
    }

    function _setExtendLogicAddress(address extendLogic) internal {
        _extendLogic = extendLogic;
    }

    // These are called by the delegatee back to self and simulates the respective extension logic
    
    function extend(address extension) public {
        callExtend(extension);
    }

    function retract(address extension) public {
        callRetract(extension);
    }
}